{"version":3,"sources":["webpack:///node_modules/@ionic/core/dist/esm/ion-reorder_2-ios.entry.js"],"names":["Reorder","hostRef","this","ev","preventDefault","stopImmediatePropagation","mode","reorderIcon","class","name","lazy","part","style","ios","md","ReorderGroup","lastToIndex","cachedHeights","scrollElTop","scrollElBottom","scrollElInitial","containerTop","containerBottom","state","disabled","ionItemReorder","gesture","enable","contentEl","el","closest","getScrollElement","scrollEl","createGesture","gestureName","gesturePriority","threshold","direction","passive","canStart","detail","onStart","onMove","onEnd","disabledChanged","destroy","listOrReorder","Promise","resolve","completeSync","selectedItemEl","reorderEl","event","target","item","findReorderItem","data","heights","length","children","sum","i","child","offsetHeight","push","$ionIndex","box","getBoundingClientRect","top","bottom","scrollBox","scrollTop","AUTO_SCROLL_MARGIN","indexForItem","selectedItemHeight","classList","add","ITEM_REORDER_SELECTED","selectedItem","scroll","autoscroll","currentY","Math","max","min","deltaY","startY","toIndex","itemIndexForTop","fromIndex","reorderMove","transform","emit","from","to","complete","bind","len","insertBefore","Array","isArray","reorderArray","transition","remove","itemHeight","value","posY","amount","SCROLL_JUMP","scrollBy","g","element","node","container","parent","parentElement","array","splice","slice"],"mappings":"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","file":"x","sourcesContent":["import { r as registerInstance, h, H as Host, d as createEvent, e as getElement } from './index-e23c3ffd.js';\nimport { b as getIonMode } from './ionic-global-fbc9a2ac.js';\nimport { b as hapticSelectionStart, c as hapticSelectionChanged, d as hapticSelectionEnd } from './haptic-da73c8fd.js';\n\nconst reorderIosCss = \":host([slot]){display:none;line-height:0;z-index:100}.reorder-icon{display:block;font-size:22px}.reorder-icon{font-size:34px;opacity:0.4}\";\n\nconst reorderMdCss = \":host([slot]){display:none;line-height:0;z-index:100}.reorder-icon{display:block;font-size:22px}.reorder-icon{font-size:31px;opacity:0.3}\";\n\nconst Reorder = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n    }\n    onClick(ev) {\n        ev.preventDefault();\n        ev.stopImmediatePropagation();\n    }\n    render() {\n        const mode = getIonMode(this);\n        const reorderIcon = mode === 'ios' ? 'reorder-three-outline' : 'reorder-two-sharp';\n        return (h(Host, { class: mode }, h(\"slot\", null, h(\"ion-icon\", { name: reorderIcon, lazy: false, class: \"reorder-icon\", part: \"icon\" }))));\n    }\n};\nReorder.style = {\n    /*STENCIL:MODE:ios*/ ios: reorderIosCss,\n    /*STENCIL:MODE:md*/ md: reorderMdCss\n};\n\nconst reorderGroupCss = \".reorder-list-active>*{-webkit-transition:-webkit-transform 300ms;transition:-webkit-transform 300ms;transition:transform 300ms;transition:transform 300ms, -webkit-transform 300ms;will-change:transform}.reorder-enabled{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.reorder-enabled ion-reorder{display:block;cursor:-webkit-grab;cursor:grab;pointer-events:all;-ms-touch-action:none;touch-action:none}.reorder-selected,.reorder-selected ion-reorder{cursor:-webkit-grabbing;cursor:grabbing}.reorder-selected{position:relative;-webkit-transition:none !important;transition:none !important;-webkit-box-shadow:0 0 10px rgba(0, 0, 0, 0.4);box-shadow:0 0 10px rgba(0, 0, 0, 0.4);opacity:0.8;z-index:100}.reorder-visible ion-reorder .reorder-icon{-webkit-transform:translate3d(0,  0,  0);transform:translate3d(0,  0,  0)}\";\n\nconst ReorderGroup = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.lastToIndex = -1;\n        this.cachedHeights = [];\n        this.scrollElTop = 0;\n        this.scrollElBottom = 0;\n        this.scrollElInitial = 0;\n        this.containerTop = 0;\n        this.containerBottom = 0;\n        this.state = 0 /* Idle */;\n        /**\n         * If `true`, the reorder will be hidden.\n         */\n        this.disabled = true;\n        this.ionItemReorder = createEvent(this, \"ionItemReorder\", 7);\n    }\n    disabledChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.disabled);\n        }\n    }\n    async connectedCallback() {\n        const contentEl = this.el.closest('ion-content');\n        if (contentEl) {\n            this.scrollEl = await contentEl.getScrollElement();\n        }\n        this.gesture = (await import('./index-6f647ec8.js')).createGesture({\n            el: this.el,\n            gestureName: 'reorder',\n            gesturePriority: 110,\n            threshold: 0,\n            direction: 'y',\n            passive: false,\n            canStart: detail => this.canStart(detail),\n            onStart: ev => this.onStart(ev),\n            onMove: ev => this.onMove(ev),\n            onEnd: () => this.onEnd(),\n        });\n        this.disabledChanged();\n    }\n    disconnectedCallback() {\n        this.onEnd();\n        if (this.gesture) {\n            this.gesture.destroy();\n            this.gesture = undefined;\n        }\n    }\n    /**\n     * Completes the reorder operation. Must be called by the `ionItemReorder` event.\n     *\n     * If a list of items is passed, the list will be reordered and returned in the\n     * proper order.\n     *\n     * If no parameters are passed or if `true` is passed in, the reorder will complete\n     * and the item will remain in the position it was dragged to. If `false` is passed,\n     * the reorder will complete and the item will bounce back to its original position.\n     *\n     * @param listOrReorder A list of items to be sorted and returned in the new order or a\n     * boolean of whether or not the reorder should reposition the item.\n     */\n    complete(listOrReorder) {\n        return Promise.resolve(this.completeSync(listOrReorder));\n    }\n    canStart(ev) {\n        if (this.selectedItemEl || this.state !== 0 /* Idle */) {\n            return false;\n        }\n        const target = ev.event.target;\n        const reorderEl = target.closest('ion-reorder');\n        if (!reorderEl) {\n            return false;\n        }\n        const item = findReorderItem(reorderEl, this.el);\n        if (!item) {\n            return false;\n        }\n        ev.data = item;\n        return true;\n    }\n    onStart(ev) {\n        ev.event.preventDefault();\n        const item = this.selectedItemEl = ev.data;\n        const heights = this.cachedHeights;\n        heights.length = 0;\n        const el = this.el;\n        const children = el.children;\n        if (!children || children.length === 0) {\n            return;\n        }\n        let sum = 0;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            sum += child.offsetHeight;\n            heights.push(sum);\n            child.$ionIndex = i;\n        }\n        const box = el.getBoundingClientRect();\n        this.containerTop = box.top;\n        this.containerBottom = box.bottom;\n        if (this.scrollEl) {\n            const scrollBox = this.scrollEl.getBoundingClientRect();\n            this.scrollElInitial = this.scrollEl.scrollTop;\n            this.scrollElTop = scrollBox.top + AUTO_SCROLL_MARGIN;\n            this.scrollElBottom = scrollBox.bottom - AUTO_SCROLL_MARGIN;\n        }\n        else {\n            this.scrollElInitial = 0;\n            this.scrollElTop = 0;\n            this.scrollElBottom = 0;\n        }\n        this.lastToIndex = indexForItem(item);\n        this.selectedItemHeight = item.offsetHeight;\n        this.state = 1 /* Active */;\n        item.classList.add(ITEM_REORDER_SELECTED);\n        hapticSelectionStart();\n    }\n    onMove(ev) {\n        const selectedItem = this.selectedItemEl;\n        if (!selectedItem) {\n            return;\n        }\n        // Scroll if we reach the scroll margins\n        const scroll = this.autoscroll(ev.currentY);\n        // // Get coordinate\n        const top = this.containerTop - scroll;\n        const bottom = this.containerBottom - scroll;\n        const currentY = Math.max(top, Math.min(ev.currentY, bottom));\n        const deltaY = scroll + currentY - ev.startY;\n        const normalizedY = currentY - top;\n        const toIndex = this.itemIndexForTop(normalizedY);\n        if (toIndex !== this.lastToIndex) {\n            const fromIndex = indexForItem(selectedItem);\n            this.lastToIndex = toIndex;\n            hapticSelectionChanged();\n            this.reorderMove(fromIndex, toIndex);\n        }\n        // Update selected item position\n        selectedItem.style.transform = `translateY(${deltaY}px)`;\n    }\n    onEnd() {\n        const selectedItemEl = this.selectedItemEl;\n        this.state = 2 /* Complete */;\n        if (!selectedItemEl) {\n            this.state = 0 /* Idle */;\n            return;\n        }\n        const toIndex = this.lastToIndex;\n        const fromIndex = indexForItem(selectedItemEl);\n        if (toIndex === fromIndex) {\n            this.completeSync();\n        }\n        else {\n            this.ionItemReorder.emit({\n                from: fromIndex,\n                to: toIndex,\n                complete: this.completeSync.bind(this)\n            });\n        }\n        hapticSelectionEnd();\n    }\n    completeSync(listOrReorder) {\n        const selectedItemEl = this.selectedItemEl;\n        if (selectedItemEl && this.state === 2 /* Complete */) {\n            const children = this.el.children;\n            const len = children.length;\n            const toIndex = this.lastToIndex;\n            const fromIndex = indexForItem(selectedItemEl);\n            if (toIndex !== fromIndex && (!listOrReorder || listOrReorder === true)) {\n                const ref = (fromIndex < toIndex)\n                    ? children[toIndex + 1]\n                    : children[toIndex];\n                this.el.insertBefore(selectedItemEl, ref);\n            }\n            if (Array.isArray(listOrReorder)) {\n                listOrReorder = reorderArray(listOrReorder, fromIndex, toIndex);\n            }\n            for (let i = 0; i < len; i++) {\n                children[i].style['transform'] = '';\n            }\n            selectedItemEl.style.transition = '';\n            selectedItemEl.classList.remove(ITEM_REORDER_SELECTED);\n            this.selectedItemEl = undefined;\n            this.state = 0 /* Idle */;\n        }\n        return listOrReorder;\n    }\n    itemIndexForTop(deltaY) {\n        const heights = this.cachedHeights;\n        let i = 0;\n        // TODO: since heights is a sorted array of integers, we can do\n        // speed up the search using binary search. Remember that linear-search is still\n        // faster than binary-search for small arrays (<64) due CPU branch misprediction.\n        for (i = 0; i < heights.length; i++) {\n            if (heights[i] > deltaY) {\n                break;\n            }\n        }\n        return i;\n    }\n    /********* DOM WRITE ********* */\n    reorderMove(fromIndex, toIndex) {\n        const itemHeight = this.selectedItemHeight;\n        const children = this.el.children;\n        for (let i = 0; i < children.length; i++) {\n            const style = children[i].style;\n            let value = '';\n            if (i > fromIndex && i <= toIndex) {\n                value = `translateY(${-itemHeight}px)`;\n            }\n            else if (i < fromIndex && i >= toIndex) {\n                value = `translateY(${itemHeight}px)`;\n            }\n            style['transform'] = value;\n        }\n    }\n    autoscroll(posY) {\n        if (!this.scrollEl) {\n            return 0;\n        }\n        let amount = 0;\n        if (posY < this.scrollElTop) {\n            amount = -SCROLL_JUMP;\n        }\n        else if (posY > this.scrollElBottom) {\n            amount = SCROLL_JUMP;\n        }\n        if (amount !== 0) {\n            this.scrollEl.scrollBy(0, amount);\n        }\n        return this.scrollEl.scrollTop - this.scrollElInitial;\n    }\n    render() {\n        const mode = getIonMode(this);\n        return (h(Host, { class: {\n                [mode]: true,\n                'reorder-enabled': !this.disabled,\n                'reorder-list-active': this.state !== 0 /* Idle */,\n            } }));\n    }\n    get el() { return getElement(this); }\n    static get watchers() { return {\n        \"disabled\": [\"disabledChanged\"]\n    }; }\n};\nconst indexForItem = (element) => {\n    return element['$ionIndex'];\n};\nconst findReorderItem = (node, container) => {\n    let parent;\n    while (node) {\n        parent = node.parentElement;\n        if (parent === container) {\n            return node;\n        }\n        node = parent;\n    }\n    return undefined;\n};\nconst AUTO_SCROLL_MARGIN = 60;\nconst SCROLL_JUMP = 10;\nconst ITEM_REORDER_SELECTED = 'reorder-selected';\nconst reorderArray = (array, from, to) => {\n    const element = array[from];\n    array.splice(from, 1);\n    array.splice(to, 0, element);\n    return array.slice();\n};\nReorderGroup.style = reorderGroupCss;\n\nexport { Reorder as ion_reorder, ReorderGroup as ion_reorder_group };\n"]}