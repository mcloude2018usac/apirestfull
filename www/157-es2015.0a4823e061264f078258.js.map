{"version":3,"sources":["webpack:///node_modules/@ionic/core/dist/esm/ion-route_4.entry.js"],"names":["Route","hostRef","this","url","ionRouteDataChanged","newValue","emit","oldValue","keys1","Object","keys","keys2","length","key","onUpdate","RouteRedirect","ionRouteRedirectChanged","generatePath","segments","filter","s","join","parsePath","path","split","map","trim","writeNavState","async","root","chain","direction","index","changed","outlet","searchNavNode","componentOnReady","route","result","setRouteId","id","params","element","markVisible","e","console","error","QUERY","matches","querySelector","undefined","routeRedirect","routes","find","input","from","to","i","expected","matchesIDs","ids","len","Math","min","toLowerCase","matchesPath","inputPath","RouterSegments","allparams","matchesDefault","segment","data","next","slice","mergeParams","a","b","assign","computePriority","score","level","pow","shift","readRedirects","Array","children","el","tagName","readProp","readRoutes","flattenRouterTree","readRouteNodes","node","component","Error","componentProps","prop","hasAttribute","getAttribute","nodes","flattenNode","push","sub","Router","previousPath","busy","state","lastState","useHash","ionRouteWillChange","ionRouteDidChange","debug","document","body","Promise","resolve","window","addEventListener","once","onRoutesChanged","onRedirectChanged","bind","historyDirection","getPath","writeNavStateRoot","ev","detail","register","processNextHandler","back","startsWith","URL","location","href","pathname","queryString","setPath","history","waitPromise","group","forEach","r","groupEnd","redirects","redirect","warn","getRouteId","chains","match","maxMatches","plainIDs","param","safeWriteNavState","win","replaceState","title","redirectFrom","matchedChain","unlock","lock","p","routeEvent","routeChangeEvent","pushState","loc","hash","prefix","redirectFromPath","redirectedFrom","g","RouterLink","routerDirection","onClick","mode","attrs","rel","target","class","color","style"],"mappings":"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","file":"x","sourcesContent":["import { r as registerInstance, d as createEvent, e as getElement, h, H as Host } from './index-e23c3ffd.js';\nimport { b as getIonMode } from './ionic-global-fbc9a2ac.js';\nimport { e as debounce } from './helpers-5c745fbd.js';\nimport { o as openURL, c as createColorClasses } from './theme-c2dc54d9.js';\n\nconst Route = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        /**\n         * Relative path that needs to match in order for this route to apply.\n         *\n         * Accepts paths similar to expressjs so that you can define parameters\n         * in the url /foo/:bar where bar would be available in incoming props.\n         */\n        this.url = '';\n        this.ionRouteDataChanged = createEvent(this, \"ionRouteDataChanged\", 7);\n    }\n    onUpdate(newValue) {\n        this.ionRouteDataChanged.emit(newValue);\n    }\n    onComponentProps(newValue, oldValue) {\n        if (newValue === oldValue) {\n            return;\n        }\n        const keys1 = newValue ? Object.keys(newValue) : [];\n        const keys2 = oldValue ? Object.keys(oldValue) : [];\n        if (keys1.length !== keys2.length) {\n            this.onUpdate(newValue);\n            return;\n        }\n        for (const key of keys1) {\n            if (newValue[key] !== oldValue[key]) {\n                this.onUpdate(newValue);\n                return;\n            }\n        }\n    }\n    connectedCallback() {\n        this.ionRouteDataChanged.emit();\n    }\n    static get watchers() { return {\n        \"url\": [\"onUpdate\"],\n        \"component\": [\"onUpdate\"],\n        \"componentProps\": [\"onComponentProps\"]\n    }; }\n};\n\nconst RouteRedirect = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.ionRouteRedirectChanged = createEvent(this, \"ionRouteRedirectChanged\", 7);\n    }\n    propDidChange() {\n        this.ionRouteRedirectChanged.emit();\n    }\n    connectedCallback() {\n        this.ionRouteRedirectChanged.emit();\n    }\n    static get watchers() { return {\n        \"from\": [\"propDidChange\"],\n        \"to\": [\"propDidChange\"]\n    }; }\n};\n\nconst ROUTER_INTENT_NONE = 'root';\nconst ROUTER_INTENT_FORWARD = 'forward';\nconst ROUTER_INTENT_BACK = 'back';\n\nconst generatePath = (segments) => {\n    const path = segments\n        .filter(s => s.length > 0)\n        .join('/');\n    return '/' + path;\n};\nconst chainToPath = (chain) => {\n    const path = [];\n    for (const route of chain) {\n        for (const segment of route.path) {\n            if (segment[0] === ':') {\n                const param = route.params && route.params[segment.slice(1)];\n                if (!param) {\n                    return null;\n                }\n                path.push(param);\n            }\n            else if (segment !== '') {\n                path.push(segment);\n            }\n        }\n    }\n    return path;\n};\nconst writePath = (history, root, useHash, path, direction, state, queryString) => {\n    let url = generatePath([\n        ...parsePath(root),\n        ...path\n    ]);\n    if (useHash) {\n        url = '#' + url;\n    }\n    if (queryString !== undefined) {\n        url = url + '?' + queryString;\n    }\n    if (direction === ROUTER_INTENT_FORWARD) {\n        history.pushState(state, '', url);\n    }\n    else {\n        history.replaceState(state, '', url);\n    }\n};\nconst removePrefix = (prefix, path) => {\n    if (prefix.length > path.length) {\n        return null;\n    }\n    if (prefix.length <= 1 && prefix[0] === '') {\n        return path;\n    }\n    for (let i = 0; i < prefix.length; i++) {\n        if (prefix[i].length > 0 && prefix[i] !== path[i]) {\n            return null;\n        }\n    }\n    if (path.length === prefix.length) {\n        return [''];\n    }\n    return path.slice(prefix.length);\n};\nconst readPath = (loc, root, useHash) => {\n    let pathname = loc.pathname;\n    if (useHash) {\n        const hash = loc.hash;\n        pathname = (hash[0] === '#')\n            ? hash.slice(1)\n            : '';\n    }\n    const prefix = parsePath(root);\n    const path = parsePath(pathname);\n    return removePrefix(prefix, path);\n};\nconst parsePath = (path) => {\n    if (path == null) {\n        return [''];\n    }\n    const removeQueryString = path.split('?')[0];\n    const segments = removeQueryString.split('/')\n        .map(s => s.trim())\n        .filter(s => s.length > 0);\n    if (segments.length === 0) {\n        return [''];\n    }\n    else {\n        return segments;\n    }\n};\n\nconst printRoutes = (routes) => {\n    console.group(`[ion-core] ROUTES[${routes.length}]`);\n    for (const chain of routes) {\n        const path = [];\n        chain.forEach(r => path.push(...r.path));\n        const ids = chain.map(r => r.id);\n        console.debug(`%c ${generatePath(path)}`, 'font-weight: bold; padding-left: 20px', '=>\\t', `(${ids.join(', ')})`);\n    }\n    console.groupEnd();\n};\nconst printRedirects = (redirects) => {\n    console.group(`[ion-core] REDIRECTS[${redirects.length}]`);\n    for (const redirect of redirects) {\n        if (redirect.to) {\n            console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to)}`, 'font-weight: bold');\n        }\n    }\n    console.groupEnd();\n};\n\nconst writeNavState = async (root, chain, direction, index, changed = false) => {\n    try {\n        // find next navigation outlet in the DOM\n        const outlet = searchNavNode(root);\n        // make sure we can continue interacting the DOM, otherwise abort\n        if (index >= chain.length || !outlet) {\n            return changed;\n        }\n        await outlet.componentOnReady();\n        const route = chain[index];\n        const result = await outlet.setRouteId(route.id, route.params, direction);\n        // if the outlet changed the page, reset navigation to neutral (no direction)\n        // this means nested outlets will not animate\n        if (result.changed) {\n            direction = ROUTER_INTENT_NONE;\n            changed = true;\n        }\n        // recursively set nested outlets\n        changed = await writeNavState(result.element, chain, direction, index + 1, changed);\n        // once all nested outlets are visible let's make the parent visible too,\n        // using markVisible prevents flickering\n        if (result.markVisible) {\n            await result.markVisible();\n        }\n        return changed;\n    }\n    catch (e) {\n        console.error(e);\n        return false;\n    }\n};\nconst readNavState = async (root) => {\n    const ids = [];\n    let outlet;\n    let node = root;\n    // tslint:disable-next-line:no-constant-condition\n    while (true) {\n        outlet = searchNavNode(node);\n        if (outlet) {\n            const id = await outlet.getRouteId();\n            if (id) {\n                node = id.element;\n                id.element = undefined;\n                ids.push(id);\n            }\n            else {\n                break;\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return { ids, outlet };\n};\nconst waitUntilNavNode = () => {\n    if (searchNavNode(document.body)) {\n        return Promise.resolve();\n    }\n    return new Promise(resolve => {\n        window.addEventListener('ionNavWillLoad', resolve, { once: true });\n    });\n};\nconst QUERY = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\nconst searchNavNode = (root) => {\n    if (!root) {\n        return undefined;\n    }\n    if (root.matches(QUERY)) {\n        return root;\n    }\n    const outlet = root.querySelector(QUERY);\n    return outlet ? outlet : undefined;\n};\n\nconst matchesRedirect = (input, route) => {\n    const { from, to } = route;\n    if (to === undefined) {\n        return false;\n    }\n    if (from.length > input.length) {\n        return false;\n    }\n    for (let i = 0; i < from.length; i++) {\n        const expected = from[i];\n        if (expected === '*') {\n            return true;\n        }\n        if (expected !== input[i]) {\n            return false;\n        }\n    }\n    return from.length === input.length;\n};\nconst routeRedirect = (path, routes) => {\n    return routes.find(route => matchesRedirect(path, route));\n};\nconst matchesIDs = (ids, chain) => {\n    const len = Math.min(ids.length, chain.length);\n    let i = 0;\n    for (; i < len; i++) {\n        if (ids[i].toLowerCase() !== chain[i].id) {\n            break;\n        }\n    }\n    return i;\n};\nconst matchesPath = (inputPath, chain) => {\n    const segments = new RouterSegments(inputPath);\n    let matchesDefault = false;\n    let allparams;\n    for (let i = 0; i < chain.length; i++) {\n        const path = chain[i].path;\n        if (path[0] === '') {\n            matchesDefault = true;\n        }\n        else {\n            for (const segment of path) {\n                const data = segments.next();\n                // data param\n                if (segment[0] === ':') {\n                    if (data === '') {\n                        return null;\n                    }\n                    allparams = allparams || [];\n                    const params = allparams[i] || (allparams[i] = {});\n                    params[segment.slice(1)] = data;\n                }\n                else if (data !== segment) {\n                    return null;\n                }\n            }\n            matchesDefault = false;\n        }\n    }\n    const matches = (matchesDefault)\n        ? matchesDefault === (segments.next() === '')\n        : true;\n    if (!matches) {\n        return null;\n    }\n    if (allparams) {\n        return chain.map((route, i) => ({\n            id: route.id,\n            path: route.path,\n            params: mergeParams(route.params, allparams[i])\n        }));\n    }\n    return chain;\n};\nconst mergeParams = (a, b) => {\n    if (!a && b) {\n        return b;\n    }\n    else if (a && !b) {\n        return a;\n    }\n    else if (a && b) {\n        return Object.assign(Object.assign({}, a), b);\n    }\n    return undefined;\n};\nconst routerIDsToChain = (ids, chains) => {\n    let match = null;\n    let maxMatches = 0;\n    const plainIDs = ids.map(i => i.id);\n    for (const chain of chains) {\n        const score = matchesIDs(plainIDs, chain);\n        if (score > maxMatches) {\n            match = chain;\n            maxMatches = score;\n        }\n    }\n    if (match) {\n        return match.map((route, i) => ({\n            id: route.id,\n            path: route.path,\n            params: mergeParams(route.params, ids[i] && ids[i].params)\n        }));\n    }\n    return null;\n};\nconst routerPathToChain = (path, chains) => {\n    let match = null;\n    let matches = 0;\n    for (const chain of chains) {\n        const matchedChain = matchesPath(path, chain);\n        if (matchedChain !== null) {\n            const score = computePriority(matchedChain);\n            if (score > matches) {\n                matches = score;\n                match = matchedChain;\n            }\n        }\n    }\n    return match;\n};\nconst computePriority = (chain) => {\n    let score = 1;\n    let level = 1;\n    for (const route of chain) {\n        for (const path of route.path) {\n            if (path[0] === ':') {\n                score += Math.pow(1, level);\n            }\n            else if (path !== '') {\n                score += Math.pow(2, level);\n            }\n            level++;\n        }\n    }\n    return score;\n};\nclass RouterSegments {\n    constructor(path) {\n        this.path = path.slice();\n    }\n    next() {\n        if (this.path.length > 0) {\n            return this.path.shift();\n        }\n        return '';\n    }\n}\n\nconst readRedirects = (root) => {\n    return Array.from(root.children)\n        .filter(el => el.tagName === 'ION-ROUTE-REDIRECT')\n        .map(el => {\n        const to = readProp(el, 'to');\n        return {\n            from: parsePath(readProp(el, 'from')),\n            to: to == null ? undefined : parsePath(to),\n        };\n    });\n};\nconst readRoutes = (root) => {\n    return flattenRouterTree(readRouteNodes(root));\n};\nconst readRouteNodes = (root, node = root) => {\n    return Array.from(node.children)\n        .filter(el => el.tagName === 'ION-ROUTE' && el.component)\n        .map(el => {\n        const component = readProp(el, 'component');\n        if (component == null) {\n            throw new Error('component missing in ion-route');\n        }\n        return {\n            path: parsePath(readProp(el, 'url')),\n            id: component.toLowerCase(),\n            params: el.componentProps,\n            children: readRouteNodes(root, el)\n        };\n    });\n};\nconst readProp = (el, prop) => {\n    if (prop in el) {\n        return el[prop];\n    }\n    if (el.hasAttribute(prop)) {\n        return el.getAttribute(prop);\n    }\n    return null;\n};\nconst flattenRouterTree = (nodes) => {\n    const routes = [];\n    for (const node of nodes) {\n        flattenNode([], routes, node);\n    }\n    return routes;\n};\nconst flattenNode = (chain, routes, node) => {\n    const s = chain.slice();\n    s.push({\n        id: node.id,\n        path: node.path,\n        params: node.params\n    });\n    if (node.children.length === 0) {\n        routes.push(s);\n        return;\n    }\n    for (const sub of node.children) {\n        flattenNode(s, routes, sub);\n    }\n};\n\nconst Router = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.previousPath = null;\n        this.busy = false;\n        this.state = 0;\n        this.lastState = 0;\n        /**\n         * By default `ion-router` will match the routes at the root path (\"/\").\n         * That can be changed when\n         *\n         */\n        this.root = '/';\n        /**\n         * The router can work in two \"modes\":\n         * - With hash: `/index.html#/path/to/page`\n         * - Without hash: `/path/to/page`\n         *\n         * Using one or another might depend in the requirements of your app and/or where it's deployed.\n         *\n         * Usually \"hash-less\" navigation works better for SEO and it's more user friendly too, but it might\n         * requires additional server-side configuration in order to properly work.\n         *\n         * On the otherside hash-navigation is much easier to deploy, it even works over the file protocol.\n         *\n         * By default, this property is `true`, change to `false` to allow hash-less URLs.\n         */\n        this.useHash = true;\n        this.ionRouteWillChange = createEvent(this, \"ionRouteWillChange\", 7);\n        this.ionRouteDidChange = createEvent(this, \"ionRouteDidChange\", 7);\n    }\n    async componentWillLoad() {\n        console.debug('[ion-router] router will load');\n        await waitUntilNavNode();\n        console.debug('[ion-router] found nav');\n        await this.onRoutesChanged();\n    }\n    componentDidLoad() {\n        window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\n        window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\n    }\n    onPopState() {\n        const direction = this.historyDirection();\n        const path = this.getPath();\n        console.debug('[ion-router] URL changed -> update nav', path, direction);\n        return this.writeNavStateRoot(path, direction);\n    }\n    onBackButton(ev) {\n        ev.detail.register(0, processNextHandler => {\n            this.back();\n            processNextHandler();\n        });\n    }\n    /**\n     * Navigate to the specified URL.\n     *\n     * @param url The url to navigate to.\n     * @param direction The direction of the animation. Defaults to `\"forward\"`.\n     */\n    push(url, direction = 'forward') {\n        if (url.startsWith('.')) {\n            url = (new URL(url, window.location.href)).pathname;\n        }\n        console.debug('[ion-router] URL pushed -> updating nav', url, direction);\n        const path = parsePath(url);\n        const queryString = url.split('?')[1];\n        this.setPath(path, direction, queryString);\n        return this.writeNavStateRoot(path, direction);\n    }\n    /**\n     * Go back to previous page in the window.history.\n     */\n    back() {\n        window.history.back();\n        return Promise.resolve(this.waitPromise);\n    }\n    /** @internal */\n    async printDebug() {\n        console.debug('CURRENT PATH', this.getPath());\n        console.debug('PREVIOUS PATH', this.previousPath);\n        printRoutes(readRoutes(this.el));\n        printRedirects(readRedirects(this.el));\n    }\n    /** @internal */\n    async navChanged(direction) {\n        if (this.busy) {\n            console.warn('[ion-router] router is busy, navChanged was cancelled');\n            return false;\n        }\n        const { ids, outlet } = await readNavState(window.document.body);\n        const routes = readRoutes(this.el);\n        const chain = routerIDsToChain(ids, routes);\n        if (!chain) {\n            console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));\n            return false;\n        }\n        const path = chainToPath(chain);\n        if (!path) {\n            console.warn('[ion-router] router could not match path because some required param is missing');\n            return false;\n        }\n        console.debug('[ion-router] nav changed -> update URL', ids, path);\n        this.setPath(path, direction);\n        await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length);\n        return true;\n    }\n    onRedirectChanged() {\n        const path = this.getPath();\n        if (path && routeRedirect(path, readRedirects(this.el))) {\n            this.writeNavStateRoot(path, ROUTER_INTENT_NONE);\n        }\n    }\n    onRoutesChanged() {\n        return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);\n    }\n    historyDirection() {\n        const win = window;\n        if (win.history.state === null) {\n            this.state++;\n            win.history.replaceState(this.state, win.document.title, win.document.location && win.document.location.href);\n        }\n        const state = win.history.state;\n        const lastState = this.lastState;\n        this.lastState = state;\n        if (state > lastState) {\n            return ROUTER_INTENT_FORWARD;\n        }\n        else if (state < lastState) {\n            return ROUTER_INTENT_BACK;\n        }\n        else {\n            return ROUTER_INTENT_NONE;\n        }\n    }\n    async writeNavStateRoot(path, direction) {\n        if (!path) {\n            console.error('[ion-router] URL is not part of the routing set');\n            return false;\n        }\n        // lookup redirect rule\n        const redirects = readRedirects(this.el);\n        const redirect = routeRedirect(path, redirects);\n        let redirectFrom = null;\n        if (redirect) {\n            this.setPath(redirect.to, direction);\n            redirectFrom = redirect.from;\n            path = redirect.to;\n        }\n        // lookup route chain\n        const routes = readRoutes(this.el);\n        const chain = routerPathToChain(path, routes);\n        if (!chain) {\n            console.error('[ion-router] the path does not match any route');\n            return false;\n        }\n        // write DOM give\n        return this.safeWriteNavState(document.body, chain, direction, path, redirectFrom);\n    }\n    async safeWriteNavState(node, chain, direction, path, redirectFrom, index = 0) {\n        const unlock = await this.lock();\n        let changed = false;\n        try {\n            changed = await this.writeNavState(node, chain, direction, path, redirectFrom, index);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        unlock();\n        return changed;\n    }\n    async lock() {\n        const p = this.waitPromise;\n        let resolve;\n        this.waitPromise = new Promise(r => resolve = r);\n        if (p !== undefined) {\n            await p;\n        }\n        return resolve;\n    }\n    async writeNavState(node, chain, direction, path, redirectFrom, index = 0) {\n        if (this.busy) {\n            console.warn('[ion-router] router is busy, transition was cancelled');\n            return false;\n        }\n        this.busy = true;\n        // generate route event and emit will change\n        const routeEvent = this.routeChangeEvent(path, redirectFrom);\n        if (routeEvent) {\n            this.ionRouteWillChange.emit(routeEvent);\n        }\n        const changed = await writeNavState(node, chain, direction, index);\n        this.busy = false;\n        if (changed) {\n            console.debug('[ion-router] route changed', path);\n        }\n        // emit did change\n        if (routeEvent) {\n            this.ionRouteDidChange.emit(routeEvent);\n        }\n        return changed;\n    }\n    setPath(path, direction, queryString) {\n        this.state++;\n        writePath(window.history, this.root, this.useHash, path, direction, this.state, queryString);\n    }\n    getPath() {\n        return readPath(window.location, this.root, this.useHash);\n    }\n    routeChangeEvent(path, redirectFromPath) {\n        const from = this.previousPath;\n        const to = generatePath(path);\n        this.previousPath = to;\n        if (to === from) {\n            return null;\n        }\n        const redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;\n        return {\n            from,\n            redirectedFrom,\n            to,\n        };\n    }\n    get el() { return getElement(this); }\n};\n\nconst routerLinkCss = \":host{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}\";\n\nconst RouterLink = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        /**\n         * When using a router, it specifies the transition direction when navigating to\n         * another page using `href`.\n         */\n        this.routerDirection = 'forward';\n        this.onClick = (ev) => {\n            openURL(this.href, ev, this.routerDirection);\n        };\n    }\n    render() {\n        const mode = getIonMode(this);\n        const attrs = {\n            href: this.href,\n            rel: this.rel,\n            target: this.target\n        };\n        return (h(Host, { onClick: this.onClick, class: Object.assign(Object.assign({}, createColorClasses(this.color)), { [mode]: true, 'ion-activatable': true }) }, h(\"a\", Object.assign({}, attrs), h(\"slot\", null))));\n    }\n};\nRouterLink.style = routerLinkCss;\n\nexport { Route as ion_route, RouteRedirect as ion_route_redirect, Router as ion_router, RouterLink as ion_router_link };\n"]}